/*
 * ApiDocumentationLib
 *
 * This file was automatically generated by APIMATIC v2.0 ( https://apimatic.io ).
 */
package localhost9095.controllers;

import java.io.*;
import java.util.*;
import java.util.concurrent.*;
import com.fasterxml.jackson.core.type.TypeReference;

import localhost9095.*;
import localhost9095.models.*;
import localhost9095.exceptions.*;
import localhost9095.http.client.HttpClient;
import localhost9095.http.client.HttpContext;
import localhost9095.http.request.HttpRequest;
import localhost9095.http.response.HttpResponse;
import localhost9095.http.response.HttpStringResponse;
import localhost9095.http.client.APICallBack;
import localhost9095.controllers.syncwrapper.APICallBackCatcher;

public class DemoController extends BaseController {
    //private static variables for the singleton pattern
    private static final Object syncObject = new Object();
    private static DemoController instance = null;

    /**
     * Singleton pattern implementation 
     * @return The singleton instance of the DemoController class 
     */
    public static DemoController getInstance() {
        if (null == instance) {
            synchronized (syncObject) {
                if (null == instance) {
                    instance = new DemoController();
                }
            }
        }
        return instance;
    }

    /**
     * This approach removes almost all the info of joins from the code area, only the where and predicates need to be given here and placed here, the rest of the info will be held in the model only.The returned object in the code JoinedQuery is an user defined one.
     * @param    univ    Required parameter: univ
     * @return    Returns the CoursesByUniversity response from the API call 
     */
    public CoursesByUniversity getCreateUsingJoinInfoUsingGET(
                final String univ
    ) throws Throwable {

        HttpRequest _request = _buildGetCreateUsingJoinInfoUsingGETRequest(univ);
        HttpResponse _response = getClientInstance().executeAsString(_request);
        HttpContext _context = new HttpContext(_request, _response);

        return _handleGetCreateUsingJoinInfoUsingGETResponse(_context);
    }

    /**
     * This approach removes almost all the info of joins from the code area, only the where and predicates need to be given here and placed here, the rest of the info will be held in the model only.The returned object in the code JoinedQuery is an user defined one.
     * @param    univ    Required parameter: univ
     */
    public void getCreateUsingJoinInfoUsingGETAsync(
                final String univ,
                final APICallBack<CoursesByUniversity> callBack
    ) {
        Runnable _responseTask = new Runnable() {
            public void run() {

                HttpRequest _request;
                try {
                    _request = _buildGetCreateUsingJoinInfoUsingGETRequest(univ);
                } catch (Exception e) {
                    callBack.onFailure(null, e);
                    return;
                }

                // Invoke request and get response
                getClientInstance().executeAsStringAsync(_request, new APICallBack<HttpResponse>() {
                    public void onSuccess(HttpContext _context, HttpResponse _response) {
                        try {
                            CoursesByUniversity returnValue = _handleGetCreateUsingJoinInfoUsingGETResponse(_context);
                            callBack.onSuccess(_context, returnValue);
                        } catch (Exception e) {
                            callBack.onFailure(_context, e);
                        }
                    }

                    public void onFailure(HttpContext _context, Throwable _exception) {
                        // Let the caller know of the failure
                        callBack.onFailure(_context, _exception);
                    }
                });
            }
        };

        // Execute async using thread pool
        APIHelper.getScheduler().execute(_responseTask);
    }

    /**
     * Builds the HttpRequest object for getCreateUsingJoinInfoUsingGET
     */
    private HttpRequest _buildGetCreateUsingJoinInfoUsingGETRequest(
                final String univ) throws IOException, APIException {
        //the base uri for api requests
        String _baseUri = Configuration.baseUri;

        //prepare query string for API call
        StringBuilder _queryBuilder = new StringBuilder(_baseUri + "/api/join/alone/{univ}");

        //process template parameters
        Map<String, Object> _templateParameters = new HashMap<String, Object>();
        _templateParameters.put("univ", univ);
        APIHelper.appendUrlWithTemplateParameters(_queryBuilder, _templateParameters);
        //validate and preprocess url
        String _queryUrl = APIHelper.cleanUrl(_queryBuilder);

        //load all headers for the outgoing API request
        Map<String, String> _headers = new HashMap<String, String>();
        _headers.put("user-agent", BaseController.userAgent);
        _headers.put("accept", "application/json");


        //prepare and invoke the API call request to fetch the response
        HttpRequest _request = getClientInstance().get(_queryUrl, _headers, null);

        // Invoke the callback before request if its not null
        if (getHttpCallBack() != null) {
            getHttpCallBack().OnBeforeRequest(_request);
        }

        return _request;
    }

    /**
     * Processes the response for getCreateUsingJoinInfoUsingGET
     * @return An object of type CoursesByUniversity
     */
    private CoursesByUniversity _handleGetCreateUsingJoinInfoUsingGETResponse(HttpContext _context)
            throws APIException, IOException {
        HttpResponse _response = _context.getResponse();

        //invoke the callback after response if its not null
        if (getHttpCallBack() != null) {
            getHttpCallBack().OnAfterResponse(_context);
        }

        //Error handling using HTTP status codes
        int _responseCode = _response.getStatusCode();

        if (_responseCode == 401) {
            throw new APIException("Unauthorized", _context);
        }
        if (_responseCode == 403) {
            throw new APIException("Forbidden", _context);
        }
        if (_responseCode == 404) {
            throw new APIException("Not Found", _context);
        }
        //handle errors defined at the API level
        validateResponse(_response, _context);

        //extract result from the http response
        String _responseBody = ((HttpStringResponse)_response).getBody();
        CoursesByUniversity _result = APIHelper.deserialize(_responseBody,
                                                        new TypeReference<CoursesByUniversity>(){});

        return _result;
    }

    /**
     * This approach is using jpa select, where there is freedom in changing the field names and also we can write code upto 100 field selects, but the code is going to be less manageable, and exactly what fields are being mapped to what model field is going to be again fixed in this place only, instead of the model holding the field information of what value it accepts
     * @param    gradYear    Required parameter: grad_year
     * @param    univ    Required parameter: univ
     * @return    Returns the StudentModelPlain response from the API call 
     */
    public StudentModelPlain getCreateUsingTypeUsingGET(
                final int gradYear,
                final String univ
    ) throws Throwable {

        HttpRequest _request = _buildGetCreateUsingTypeUsingGETRequest(gradYear, univ);
        HttpResponse _response = getClientInstance().executeAsString(_request);
        HttpContext _context = new HttpContext(_request, _response);

        return _handleGetCreateUsingTypeUsingGETResponse(_context);
    }

    /**
     * This approach is using jpa select, where there is freedom in changing the field names and also we can write code upto 100 field selects, but the code is going to be less manageable, and exactly what fields are being mapped to what model field is going to be again fixed in this place only, instead of the model holding the field information of what value it accepts
     * @param    gradYear    Required parameter: grad_year
     * @param    univ    Required parameter: univ
     */
    public void getCreateUsingTypeUsingGETAsync(
                final int gradYear,
                final String univ,
                final APICallBack<StudentModelPlain> callBack
    ) {
        Runnable _responseTask = new Runnable() {
            public void run() {

                HttpRequest _request;
                try {
                    _request = _buildGetCreateUsingTypeUsingGETRequest(gradYear, univ);
                } catch (Exception e) {
                    callBack.onFailure(null, e);
                    return;
                }

                // Invoke request and get response
                getClientInstance().executeAsStringAsync(_request, new APICallBack<HttpResponse>() {
                    public void onSuccess(HttpContext _context, HttpResponse _response) {
                        try {
                            StudentModelPlain returnValue = _handleGetCreateUsingTypeUsingGETResponse(_context);
                            callBack.onSuccess(_context, returnValue);
                        } catch (Exception e) {
                            callBack.onFailure(_context, e);
                        }
                    }

                    public void onFailure(HttpContext _context, Throwable _exception) {
                        // Let the caller know of the failure
                        callBack.onFailure(_context, _exception);
                    }
                });
            }
        };

        // Execute async using thread pool
        APIHelper.getScheduler().execute(_responseTask);
    }

    /**
     * Builds the HttpRequest object for getCreateUsingTypeUsingGET
     */
    private HttpRequest _buildGetCreateUsingTypeUsingGETRequest(
                final int gradYear,
                final String univ) throws IOException, APIException {
        //the base uri for api requests
        String _baseUri = Configuration.baseUri;

        //prepare query string for API call
        StringBuilder _queryBuilder = new StringBuilder(_baseUri + "/api/jpaselect/{grad_year}/{univ}");

        //process template parameters
        Map<String, Object> _templateParameters = new HashMap<String, Object>();
        _templateParameters.put("grad_year", gradYear);
        _templateParameters.put("univ", univ);
        APIHelper.appendUrlWithTemplateParameters(_queryBuilder, _templateParameters);
        //validate and preprocess url
        String _queryUrl = APIHelper.cleanUrl(_queryBuilder);

        //load all headers for the outgoing API request
        Map<String, String> _headers = new HashMap<String, String>();
        _headers.put("user-agent", BaseController.userAgent);
        _headers.put("accept", "application/json");


        //prepare and invoke the API call request to fetch the response
        HttpRequest _request = getClientInstance().get(_queryUrl, _headers, null);

        // Invoke the callback before request if its not null
        if (getHttpCallBack() != null) {
            getHttpCallBack().OnBeforeRequest(_request);
        }

        return _request;
    }

    /**
     * Processes the response for getCreateUsingTypeUsingGET
     * @return An object of type StudentModelPlain
     */
    private StudentModelPlain _handleGetCreateUsingTypeUsingGETResponse(HttpContext _context)
            throws APIException, IOException {
        HttpResponse _response = _context.getResponse();

        //invoke the callback after response if its not null
        if (getHttpCallBack() != null) {
            getHttpCallBack().OnAfterResponse(_context);
        }

        //Error handling using HTTP status codes
        int _responseCode = _response.getStatusCode();

        if (_responseCode == 401) {
            throw new APIException("Unauthorized", _context);
        }
        if (_responseCode == 403) {
            throw new APIException("Forbidden", _context);
        }
        if (_responseCode == 404) {
            throw new APIException("Not Found", _context);
        }
        //handle errors defined at the API level
        validateResponse(_response, _context);

        //extract result from the http response
        String _responseBody = ((HttpStringResponse)_response).getBody();
        StudentModelPlain _result = APIHelper.deserialize(_responseBody,
                                                        new TypeReference<StudentModelPlain>(){});

        return _result;
    }

    /**
     * This approach removes almost all the info of joins from the code area, only the where and predicates need to be given here and placed here, the rest of the info will be held in the model only.The returned object in the code JoinedQuery is an user defined one.
     * @param    gradYear    Required parameter: grad_year
     * @param    univ    Required parameter: univ
     * @return    Returns the StudentModelWithJoinInfo response from the API call 
     */
    public StudentModelWithJoinInfo getCreateUsingCustomAnnotationUsingGET(
                final int gradYear,
                final String univ
    ) throws Throwable {

        HttpRequest _request = _buildGetCreateUsingCustomAnnotationUsingGETRequest(gradYear, univ);
        HttpResponse _response = getClientInstance().executeAsString(_request);
        HttpContext _context = new HttpContext(_request, _response);

        return _handleGetCreateUsingCustomAnnotationUsingGETResponse(_context);
    }

    /**
     * This approach removes almost all the info of joins from the code area, only the where and predicates need to be given here and placed here, the rest of the info will be held in the model only.The returned object in the code JoinedQuery is an user defined one.
     * @param    gradYear    Required parameter: grad_year
     * @param    univ    Required parameter: univ
     */
    public void getCreateUsingCustomAnnotationUsingGETAsync(
                final int gradYear,
                final String univ,
                final APICallBack<StudentModelWithJoinInfo> callBack
    ) {
        Runnable _responseTask = new Runnable() {
            public void run() {

                HttpRequest _request;
                try {
                    _request = _buildGetCreateUsingCustomAnnotationUsingGETRequest(gradYear, univ);
                } catch (Exception e) {
                    callBack.onFailure(null, e);
                    return;
                }

                // Invoke request and get response
                getClientInstance().executeAsStringAsync(_request, new APICallBack<HttpResponse>() {
                    public void onSuccess(HttpContext _context, HttpResponse _response) {
                        try {
                            StudentModelWithJoinInfo returnValue = _handleGetCreateUsingCustomAnnotationUsingGETResponse(_context);
                            callBack.onSuccess(_context, returnValue);
                        } catch (Exception e) {
                            callBack.onFailure(_context, e);
                        }
                    }

                    public void onFailure(HttpContext _context, Throwable _exception) {
                        // Let the caller know of the failure
                        callBack.onFailure(_context, _exception);
                    }
                });
            }
        };

        // Execute async using thread pool
        APIHelper.getScheduler().execute(_responseTask);
    }

    /**
     * Builds the HttpRequest object for getCreateUsingCustomAnnotationUsingGET
     */
    private HttpRequest _buildGetCreateUsingCustomAnnotationUsingGETRequest(
                final int gradYear,
                final String univ) throws IOException, APIException {
        //the base uri for api requests
        String _baseUri = Configuration.baseUri;

        //prepare query string for API call
        StringBuilder _queryBuilder = new StringBuilder(_baseUri + "/api/mostefficient/{grad_year}/{univ}");

        //process template parameters
        Map<String, Object> _templateParameters = new HashMap<String, Object>();
        _templateParameters.put("grad_year", gradYear);
        _templateParameters.put("univ", univ);
        APIHelper.appendUrlWithTemplateParameters(_queryBuilder, _templateParameters);
        //validate and preprocess url
        String _queryUrl = APIHelper.cleanUrl(_queryBuilder);

        //load all headers for the outgoing API request
        Map<String, String> _headers = new HashMap<String, String>();
        _headers.put("user-agent", BaseController.userAgent);
        _headers.put("accept", "application/json");


        //prepare and invoke the API call request to fetch the response
        HttpRequest _request = getClientInstance().get(_queryUrl, _headers, null);

        // Invoke the callback before request if its not null
        if (getHttpCallBack() != null) {
            getHttpCallBack().OnBeforeRequest(_request);
        }

        return _request;
    }

    /**
     * Processes the response for getCreateUsingCustomAnnotationUsingGET
     * @return An object of type StudentModelWithJoinInfo
     */
    private StudentModelWithJoinInfo _handleGetCreateUsingCustomAnnotationUsingGETResponse(HttpContext _context)
            throws APIException, IOException {
        HttpResponse _response = _context.getResponse();

        //invoke the callback after response if its not null
        if (getHttpCallBack() != null) {
            getHttpCallBack().OnAfterResponse(_context);
        }

        //Error handling using HTTP status codes
        int _responseCode = _response.getStatusCode();

        if (_responseCode == 401) {
            throw new APIException("Unauthorized", _context);
        }
        if (_responseCode == 403) {
            throw new APIException("Forbidden", _context);
        }
        if (_responseCode == 404) {
            throw new APIException("Not Found", _context);
        }
        //handle errors defined at the API level
        validateResponse(_response, _context);

        //extract result from the http response
        String _responseBody = ((HttpStringResponse)_response).getBody();
        StudentModelWithJoinInfo _result = APIHelper.deserialize(_responseBody,
                                                        new TypeReference<StudentModelWithJoinInfo>(){});

        return _result;
    }

    /**
     * This approach is not recommended, as we have to know sql grammar and also it has to be written perfectly to provide the entire information inside the query, the table name cannot be changed later, the field name should be fixed here, then again if we use more than 100 fields to fetch, this is not the best approach. This could potentially open up sql injection and does not provide even first level of type safety
     * @param    gradYear    Required parameter: grad_year
     * @param    univ    Required parameter: univ
     * @return    Returns the StudentModelPlain response from the API call 
     */
    public StudentModelPlain getMappingUsingGET(
                final int gradYear,
                final String univ
    ) throws Throwable {

        HttpRequest _request = _buildGetMappingUsingGETRequest(gradYear, univ);
        HttpResponse _response = getClientInstance().executeAsString(_request);
        HttpContext _context = new HttpContext(_request, _response);

        return _handleGetMappingUsingGETResponse(_context);
    }

    /**
     * This approach is not recommended, as we have to know sql grammar and also it has to be written perfectly to provide the entire information inside the query, the table name cannot be changed later, the field name should be fixed here, then again if we use more than 100 fields to fetch, this is not the best approach. This could potentially open up sql injection and does not provide even first level of type safety
     * @param    gradYear    Required parameter: grad_year
     * @param    univ    Required parameter: univ
     */
    public void getMappingUsingGETAsync(
                final int gradYear,
                final String univ,
                final APICallBack<StudentModelPlain> callBack
    ) {
        Runnable _responseTask = new Runnable() {
            public void run() {

                HttpRequest _request;
                try {
                    _request = _buildGetMappingUsingGETRequest(gradYear, univ);
                } catch (Exception e) {
                    callBack.onFailure(null, e);
                    return;
                }

                // Invoke request and get response
                getClientInstance().executeAsStringAsync(_request, new APICallBack<HttpResponse>() {
                    public void onSuccess(HttpContext _context, HttpResponse _response) {
                        try {
                            StudentModelPlain returnValue = _handleGetMappingUsingGETResponse(_context);
                            callBack.onSuccess(_context, returnValue);
                        } catch (Exception e) {
                            callBack.onFailure(_context, e);
                        }
                    }

                    public void onFailure(HttpContext _context, Throwable _exception) {
                        // Let the caller know of the failure
                        callBack.onFailure(_context, _exception);
                    }
                });
            }
        };

        // Execute async using thread pool
        APIHelper.getScheduler().execute(_responseTask);
    }

    /**
     * Builds the HttpRequest object for getMappingUsingGET
     */
    private HttpRequest _buildGetMappingUsingGETRequest(
                final int gradYear,
                final String univ) throws IOException, APIException {
        //the base uri for api requests
        String _baseUri = Configuration.baseUri;

        //prepare query string for API call
        StringBuilder _queryBuilder = new StringBuilder(_baseUri + "/api/native/{grad_year}/{univ}");

        //process template parameters
        Map<String, Object> _templateParameters = new HashMap<String, Object>();
        _templateParameters.put("grad_year", gradYear);
        _templateParameters.put("univ", univ);
        APIHelper.appendUrlWithTemplateParameters(_queryBuilder, _templateParameters);
        //validate and preprocess url
        String _queryUrl = APIHelper.cleanUrl(_queryBuilder);

        //load all headers for the outgoing API request
        Map<String, String> _headers = new HashMap<String, String>();
        _headers.put("user-agent", BaseController.userAgent);
        _headers.put("accept", "application/json");


        //prepare and invoke the API call request to fetch the response
        HttpRequest _request = getClientInstance().get(_queryUrl, _headers, null);

        // Invoke the callback before request if its not null
        if (getHttpCallBack() != null) {
            getHttpCallBack().OnBeforeRequest(_request);
        }

        return _request;
    }

    /**
     * Processes the response for getMappingUsingGET
     * @return An object of type StudentModelPlain
     */
    private StudentModelPlain _handleGetMappingUsingGETResponse(HttpContext _context)
            throws APIException, IOException {
        HttpResponse _response = _context.getResponse();

        //invoke the callback after response if its not null
        if (getHttpCallBack() != null) {
            getHttpCallBack().OnAfterResponse(_context);
        }

        //Error handling using HTTP status codes
        int _responseCode = _response.getStatusCode();

        if (_responseCode == 401) {
            throw new APIException("Unauthorized", _context);
        }
        if (_responseCode == 403) {
            throw new APIException("Forbidden", _context);
        }
        if (_responseCode == 404) {
            throw new APIException("Not Found", _context);
        }
        //handle errors defined at the API level
        validateResponse(_response, _context);

        //extract result from the http response
        String _responseBody = ((HttpStringResponse)_response).getBody();
        StudentModelPlain _result = APIHelper.deserialize(_responseBody,
                                                        new TypeReference<StudentModelPlain>(){});

        return _result;
    }

    /**
     * This approach removes almost all the info of joins from the code area, only the where and predicates need to be given here and placed here, the rest of the info will be held in the model only.The returned object in the code JoinedQuery is an user defined one.
     * @param    gradYear    Required parameter: grad_year
     * @param    univ    Required parameter: univ
     * @return    Returns the StudentsUnderCourses response from the API call 
     */
    public StudentsUnderCourses getCreateUsingInheritedAnnotationsUsingGET(
                final int gradYear,
                final String univ
    ) throws Throwable {

        HttpRequest _request = _buildGetCreateUsingInheritedAnnotationsUsingGETRequest(gradYear, univ);
        HttpResponse _response = getClientInstance().executeAsString(_request);
        HttpContext _context = new HttpContext(_request, _response);

        return _handleGetCreateUsingInheritedAnnotationsUsingGETResponse(_context);
    }

    /**
     * This approach removes almost all the info of joins from the code area, only the where and predicates need to be given here and placed here, the rest of the info will be held in the model only.The returned object in the code JoinedQuery is an user defined one.
     * @param    gradYear    Required parameter: grad_year
     * @param    univ    Required parameter: univ
     */
    public void getCreateUsingInheritedAnnotationsUsingGETAsync(
                final int gradYear,
                final String univ,
                final APICallBack<StudentsUnderCourses> callBack
    ) {
        Runnable _responseTask = new Runnable() {
            public void run() {

                HttpRequest _request;
                try {
                    _request = _buildGetCreateUsingInheritedAnnotationsUsingGETRequest(gradYear, univ);
                } catch (Exception e) {
                    callBack.onFailure(null, e);
                    return;
                }

                // Invoke request and get response
                getClientInstance().executeAsStringAsync(_request, new APICallBack<HttpResponse>() {
                    public void onSuccess(HttpContext _context, HttpResponse _response) {
                        try {
                            StudentsUnderCourses returnValue = _handleGetCreateUsingInheritedAnnotationsUsingGETResponse(_context);
                            callBack.onSuccess(_context, returnValue);
                        } catch (Exception e) {
                            callBack.onFailure(_context, e);
                        }
                    }

                    public void onFailure(HttpContext _context, Throwable _exception) {
                        // Let the caller know of the failure
                        callBack.onFailure(_context, _exception);
                    }
                });
            }
        };

        // Execute async using thread pool
        APIHelper.getScheduler().execute(_responseTask);
    }

    /**
     * Builds the HttpRequest object for getCreateUsingInheritedAnnotationsUsingGET
     */
    private HttpRequest _buildGetCreateUsingInheritedAnnotationsUsingGETRequest(
                final int gradYear,
                final String univ) throws IOException, APIException {
        //the base uri for api requests
        String _baseUri = Configuration.baseUri;

        //prepare query string for API call
        StringBuilder _queryBuilder = new StringBuilder(_baseUri + "/api/power/of/inheritance/{grad_year}/{univ}");

        //process template parameters
        Map<String, Object> _templateParameters = new HashMap<String, Object>();
        _templateParameters.put("grad_year", gradYear);
        _templateParameters.put("univ", univ);
        APIHelper.appendUrlWithTemplateParameters(_queryBuilder, _templateParameters);
        //validate and preprocess url
        String _queryUrl = APIHelper.cleanUrl(_queryBuilder);

        //load all headers for the outgoing API request
        Map<String, String> _headers = new HashMap<String, String>();
        _headers.put("user-agent", BaseController.userAgent);
        _headers.put("accept", "application/json");


        //prepare and invoke the API call request to fetch the response
        HttpRequest _request = getClientInstance().get(_queryUrl, _headers, null);

        // Invoke the callback before request if its not null
        if (getHttpCallBack() != null) {
            getHttpCallBack().OnBeforeRequest(_request);
        }

        return _request;
    }

    /**
     * Processes the response for getCreateUsingInheritedAnnotationsUsingGET
     * @return An object of type StudentsUnderCourses
     */
    private StudentsUnderCourses _handleGetCreateUsingInheritedAnnotationsUsingGETResponse(HttpContext _context)
            throws APIException, IOException {
        HttpResponse _response = _context.getResponse();

        //invoke the callback after response if its not null
        if (getHttpCallBack() != null) {
            getHttpCallBack().OnAfterResponse(_context);
        }

        //Error handling using HTTP status codes
        int _responseCode = _response.getStatusCode();

        if (_responseCode == 401) {
            throw new APIException("Unauthorized", _context);
        }
        if (_responseCode == 403) {
            throw new APIException("Forbidden", _context);
        }
        if (_responseCode == 404) {
            throw new APIException("Not Found", _context);
        }
        //handle errors defined at the API level
        validateResponse(_response, _context);

        //extract result from the http response
        String _responseBody = ((HttpStringResponse)_response).getBody();
        StudentsUnderCourses _result = APIHelper.deserialize(_responseBody,
                                                        new TypeReference<StudentsUnderCourses>(){});

        return _result;
    }

    /**
     * This approach removes almost all the info of joins from the code area, only the where and predicates need to be given here and placed here, the rest of the info will be held in the model only.The returned object in the code JoinedQuery is an user defined one. The joins only happen for objects which are included in the class, not on objects which are fetched form DB
     * @param    gradYear    Required parameter: grad_year
     * @return    Returns the StudentsUnderCourses response from the API call 
     */
    public StudentsUnderCourses getCreateUsingRootAloneUsingGET(
                final int gradYear
    ) throws Throwable {

        HttpRequest _request = _buildGetCreateUsingRootAloneUsingGETRequest(gradYear);
        HttpResponse _response = getClientInstance().executeAsString(_request);
        HttpContext _context = new HttpContext(_request, _response);

        return _handleGetCreateUsingRootAloneUsingGETResponse(_context);
    }

    /**
     * This approach removes almost all the info of joins from the code area, only the where and predicates need to be given here and placed here, the rest of the info will be held in the model only.The returned object in the code JoinedQuery is an user defined one. The joins only happen for objects which are included in the class, not on objects which are fetched form DB
     * @param    gradYear    Required parameter: grad_year
     */
    public void getCreateUsingRootAloneUsingGETAsync(
                final int gradYear,
                final APICallBack<StudentsUnderCourses> callBack
    ) {
        Runnable _responseTask = new Runnable() {
            public void run() {

                HttpRequest _request;
                try {
                    _request = _buildGetCreateUsingRootAloneUsingGETRequest(gradYear);
                } catch (Exception e) {
                    callBack.onFailure(null, e);
                    return;
                }

                // Invoke request and get response
                getClientInstance().executeAsStringAsync(_request, new APICallBack<HttpResponse>() {
                    public void onSuccess(HttpContext _context, HttpResponse _response) {
                        try {
                            StudentsUnderCourses returnValue = _handleGetCreateUsingRootAloneUsingGETResponse(_context);
                            callBack.onSuccess(_context, returnValue);
                        } catch (Exception e) {
                            callBack.onFailure(_context, e);
                        }
                    }

                    public void onFailure(HttpContext _context, Throwable _exception) {
                        // Let the caller know of the failure
                        callBack.onFailure(_context, _exception);
                    }
                });
            }
        };

        // Execute async using thread pool
        APIHelper.getScheduler().execute(_responseTask);
    }

    /**
     * Builds the HttpRequest object for getCreateUsingRootAloneUsingGET
     */
    private HttpRequest _buildGetCreateUsingRootAloneUsingGETRequest(
                final int gradYear) throws IOException, APIException {
        //the base uri for api requests
        String _baseUri = Configuration.baseUri;

        //prepare query string for API call
        StringBuilder _queryBuilder = new StringBuilder(_baseUri + "/api/root/alone/{grad_year}");

        //process template parameters
        Map<String, Object> _templateParameters = new HashMap<String, Object>();
        _templateParameters.put("grad_year", gradYear);
        APIHelper.appendUrlWithTemplateParameters(_queryBuilder, _templateParameters);
        //validate and preprocess url
        String _queryUrl = APIHelper.cleanUrl(_queryBuilder);

        //load all headers for the outgoing API request
        Map<String, String> _headers = new HashMap<String, String>();
        _headers.put("user-agent", BaseController.userAgent);
        _headers.put("accept", "application/json");


        //prepare and invoke the API call request to fetch the response
        HttpRequest _request = getClientInstance().get(_queryUrl, _headers, null);

        // Invoke the callback before request if its not null
        if (getHttpCallBack() != null) {
            getHttpCallBack().OnBeforeRequest(_request);
        }

        return _request;
    }

    /**
     * Processes the response for getCreateUsingRootAloneUsingGET
     * @return An object of type StudentsUnderCourses
     */
    private StudentsUnderCourses _handleGetCreateUsingRootAloneUsingGETResponse(HttpContext _context)
            throws APIException, IOException {
        HttpResponse _response = _context.getResponse();

        //invoke the callback after response if its not null
        if (getHttpCallBack() != null) {
            getHttpCallBack().OnAfterResponse(_context);
        }

        //Error handling using HTTP status codes
        int _responseCode = _response.getStatusCode();

        if (_responseCode == 401) {
            throw new APIException("Unauthorized", _context);
        }
        if (_responseCode == 403) {
            throw new APIException("Forbidden", _context);
        }
        if (_responseCode == 404) {
            throw new APIException("Not Found", _context);
        }
        //handle errors defined at the API level
        validateResponse(_response, _context);

        //extract result from the http response
        String _responseBody = ((HttpStringResponse)_response).getBody();
        StudentsUnderCourses _result = APIHelper.deserialize(_responseBody,
                                                        new TypeReference<StudentsUnderCourses>(){});

        return _result;
    }

}
